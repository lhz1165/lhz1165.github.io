---
layout: post
title: "xv6-lab4"
category: os-6s081
---

6.s081 lab4 page

# lab4
## 背景

satp：保存页表

sepc：trap过程的程序计数器

sscratch：保存 trapframe页的虚拟地址

stvec保存进入内核代码的pc地址（trampoline代码起始地址0x3ffffff000）

## 如何保存用户寄存器

1 sscratch寄存器，启动是进入user空间之前，kernel会把trapframe页地址(0x3fffffe000)保存在这里面

2 可以在trapframe上面用来保存32个用户寄存器（系统调用参数在寄存器上，所以参数也保存在trapframe上面）

## trap的过程

用户空间调用write()，设置系统调用编号，执行ecall-> trampoline(每个进程指向同一个物理内存代码) ->内核

### 用户态代码

ecall（硬件操作）：

1. usermode 到supervisormode，
1. 把usermode代码的pc地址保存在sepc（为了返回usermode 继续执行）
1. 跳转到stvec的内核代码（让pc=3ffffff000,trampoline.S的代码位置）

### trampoline代码（uservec部分进入内核前准备）

注： trampoline物理地址和虚拟地址直接映射的

csrrw   a0,sscratch,a0，（把系统调用的参数从a0交换到sscratch，sscratch是内核trapframe栈的地址，交换之后a0是内核trapframe栈地址，sscratch是系统调用参数）

**1.先sd**

保存32个寄存器到trapframe（从0x3fffffe000往后）

保存sscratch(系统调用参数)

**2.然后ld**

读取内核的栈指针到sp

读取usertrap()地址到t0

读取kernel page table地址到satp（切换成了kernel页表）

**3.jr t0**

跳转到t0的usertrap()内核代码

### 内核trap.c的 usertrap()

stvec设置为内核地址

保存sepc（用户代码位置）到当前内核的的epc，防止进程切换修改之前的sepc

sepc = sepc+4，表示用户空间的ecall后的下一条指令

根据case的值if else判断是那种trap，如果是8表示系统调用，执行syscall()

系统调用完成之后**usertrapret();**

### usertrapret()

关中断（如果这时候发生中断，会走向用户的trap代码，会导致内核出错）

更新stvec为trampoline代码位置，方便用户下次进入内核使用

保存内核寄存器指针（页表，内核栈，usertrap()地址）

pc设置为sepc的值

satp设置为user page table （切换成了user页表）

跳到trampoline代码，恢复用户寄存器的地方

### trampoline代码（userret部分进入用户空间前准备）

切换页表

sscratch保存系统调用返回值

恢复32个寄存器

csrrw   a0,sscratch,a0，（把系统调用的返回值sscratch交换到a0，sscratch是内核统调用的返回值，交换之后a0是系统调用返回值，sscratch是内核trapframe栈地址）

**sret**

切换用户模式，

复制sepc到pc

跳转到stvec的用户代码





## 实验结果

