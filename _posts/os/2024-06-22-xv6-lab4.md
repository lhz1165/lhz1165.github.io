---
layout: post
title: "xv6-lab4"
category: os-6s081
---

6.s081 lab4 page

# Lab4: traps
## 基本概念

satp：保存页表地址（用户态和内核态）

sepc：保存用户态的下一条指令的地址（用来内核到用户的恢复）

sscratch：保存 trapframe页的虚拟地址

stvec：保存进入内核trampoline代码的pc地址（trampoline代码起始地址0x3ffffff000）

## 如何保存用户寄存器

1 sscratch寄存器，启动是进入user空间之前，kernel会把trapframe页地址保存在这里面

2 可以在trapframe上面用来保存32个用户寄存器（系统调用参数在寄存器上，所以参数也保存在trapframe上面）

## trap的过程

用户空间调用write()，设置系统调用编号，执行ecall-> trampoline(每个进程指向同一个物理内存代码) ->内核

### 1-1用户态代码 user->kernel

ecall（硬件操作）：

1. usermode 到supervisormode，
1. 把usermode代码的pc地址保存在sepc（为了返回usermode 继续执行）
1. 跳转到stvec的内核代码（让pc=3ffffff000,trampoline.S的代码位置）

### 1-2trampoline代码（uservec部分进入内核前准备）

注： trampoline物理地址和虚拟地址直接映射的

csrrw   a0,sscratch,a0，（把系统调用的参数从a0交换到sscratch，sscratch是内核trapframe栈的地址，交换之后a0是内核trapframe栈地址，sscratch是系统调用参数）

**1.先sd**

保存32个寄存器到trapframe（从0x3fffffe000往后）

保存sscratch(系统调用参数)

**2.然后ld**

读取内核的栈指针到sp

读取usertrap()地址到t0

读取kernel page table地址到satp（切换成了kernel页表）

**3.jr t0**

跳转到t0的usertrap()内核代码

### 1-3内核trap.c的 usertrap()

stvec设置为内核地址

保存sepc（用户代码位置）到当前内核的的epc，防止进程切换修改之前的sepc

sepc = sepc+4，表示用户空间的ecall后的下一条指令

根据case的值if else判断是那种trap，如果是8表示系统调用，执行syscall()

系统调用完成之后**usertrapret();**

### 2-1usertrapret() kernel->user

关中断（如果这时候发生中断，会走向用户的trap代码，会导致内核出错）

更新stvec为trampoline代码位置，方便用户下次进入内核使用

保存内核寄存器指针（页表，内核栈，usertrap()地址）

pc设置为sepc的值

satp设置为user page table （切换成了user页表）

跳到trampoline代码，恢复用户寄存器的地方

### 2-2trampoline代码（userret部分进入用户空间前准备）

切换页表

sscratch保存系统调用返回值

恢复32个寄存器

csrrw   a0,sscratch,a0，（把系统调用的返回值sscratch交换到a0，sscratch是内核统调用的返回值，交换之后a0是系统调用返回值，sscratch是内核trapframe栈地址）

**sret**

切换用户模式，

复制sepc到pc

跳转到stvec的用户代码

## Lab: traps

```
git checkout traps
```

## phase2 Backtrace ([moderate](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))

xv6栈调用图

![image-20240427143035383](/assets/malloc/p2_1.png)



每个栈帧中的最后一行存放的是返回地址，打印出来就好

fp 寄存器指向当前栈帧的开始地址

sp寄存器指向栈帧的结束地址

return地址在 fp-8的地址处 处

上一个栈帧在fp-16的地址所指向的地址处



```c
void backtrace(){
  //uint64 ksp =(myproc()->trapframe->kernel_sp); 0x0000003fffffa000 表示栈顶指针
printf("backtrace: \n");
  //s0 0x0000003fffff9f80  当前栈帧指针
  uint64 cfpV = r_fp();
  uint64 curPage = PGROUNDUP(cfpV);
  while(curPage == PGROUNDUP(cfpV)){
    uint64* returnAddrP = (uint64 *)(cfpV-8);
    printf("%p\n", *returnAddrP);
    cfpV = *(uint64 *)(cfpV - 16);
  }
}
```

## Alarm ([hard](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))







## 实验结果

