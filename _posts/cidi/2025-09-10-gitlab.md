---
layout: post
title: "gitlab cidi"
category: CI/DI
---

mysql主从同步

# WSL+DOCKER 搭建 Gitlab +Runner

目标：实现代码管理，自动运维CI/DI

## 部署gitlab

管理代码仓库

```
# 拉取Gitlab镜像
docker pull gitlab/gitlab-ce:latest
```
本地9980映射到容器80，因此容器gitlab地址不需要加端口

```
# 启动容器
docker run \
 -itd  \
 -p 9980:80 \
 -p 9922:22 \
 -v /home/gitlab/etc:/etc/gitlab  \
 -v /home/gitlab/log:/var/log/gitlab \
 -v /home/gitlab/opt:/var/opt/gitlab \
 --restart always \
 --privileged=true \
 --name gitlab \
 gitlab/gitlab-ce
```

### 编辑配置

url改成本机的ip，方便别的机器访问

```
#进容器内部
docker exec -it gitlab /bin/bash
 
#修改gitlab.rb
vi /etc/gitlab/gitlab.rb
 
#加入如下
#gitlab访问地址，本地widnows的ip，不改默认localhost 外面的机器访问不了默认本地80端口
external_url 'http://192.168.0.79'
#ssh主机ip
gitlab_rails['gitlab_ssh_host'] = '192.168.0.79'
#ssh连接端口
gitlab_rails['gitlab_shell_ssh_port'] = 9922
 
# 让配置生效
gitlab-ctl reconfigure
```

或者直接在docker desktop编辑

![image-20231114155112689]({{ "/assets/cidi/1.png" | absolute_url }})

```
# 修改http和ssh配置
vi /var/opt/gitlab/gitlab-rails/etc/gitlab.yml
 
  gitlab:
    host: 192.168.0.79
    port: 9980 #这里改为9980前端端口
    https: false
```



![image-20231114155112689]({{ "/assets/cidi/2.png" | absolute_url }})

```
#重启gitlab 
gitlab-ctl restart

gitlab-ctl reconfigure
```

管理员账户配置

```shell
# 进入容器内部
docker exec -it gitlab /bin/bash
 
# 进入控制台
gitlab-rails console -e production
 
# 查询id为1的用户，id为1的用户是超级管理员
user = User.where(id:1).first
# 修改密码为lhx123456
user.password='lhx123456'
# 保存
user.save!
# 退出
exit
 
```

### 登录

http://192.168.1.102:9980/

![image-20231114155112689]({{ "/assets/cidi/3.png" | absolute_url }})



## 部署gitlab runner

### 创建 runner 的容器

```
rm -rf /home/laihz/gitlab/runner-config
mkdir -p /home/laihz/gitlab/runner-config

docker run -d --name gitlab-runner --restart always -v /home/laihz/gitlab/runner-config:/etc/gitlab-runner -v /var/run/docker.sock:/var/run/docker.sock --privileged=true gitlab/gitlab-runner:latest
```

### 为git lab注册配置runner

为group配置runner

1.进入group

![image-20231114155112689]({{ "/assets/cidi/4.png" | absolute_url }})

2.添加runner

![image-20231114155112689]({{ "/assets/cidi/5.png" | absolute_url }})

3.获取toekn

![image-20231114155112689]({{ "/assets/cidi/6.png" | absolute_url }})

gitlab-runner register  --url http://192.168.1.102:9980  --token glrt-k0rFmuegrgkfpFlTwuk92Wc6MwpvOjEKdDoyCnU6MQ8.01.170n4nu11

进入Runner容器，根据命令创建runner

![image-20231114155112689]({{ "/assets/cidi/7.png" | absolute_url }})

页面查看，创建完毕

![image-20231114155112689]({{ "/assets/cidi/8.png" | absolute_url }})

创建/.gitlab-ci.yml，然后提交代码测试

![image-20231114155112689]({{ "/assets/cidi/9.png" | absolute_url }})



### 为gitlab runner配置ssh

gitlabrunner启动后，会在linux单独创建一个gitlab-runner的用户，流水线操作全在里面，因此需要配置ssh方便拉取代码

```
su - gitlab-runner
ssh-keygen -t rsa -b 4096 -C "gitlab-runner@container"
```



在 `/home/gitlab-runner/.ssh/config` 添加（如果没有就新建）

(我拉取代码的地址是 git clone ssh://git@125.124.128.235:50022/project/jinjiang-data-cleaning.git)

```
Host 125.124.128.235
  HostName 125.124.128.235
  Port 50022
  User git
  IdentityFile ~/.ssh/id_rsa
  StrictHostKeyChecking no
```

测试

```
ssh -T git@125.124.128.235
#会返回以下提示，我把公钥配置在我的gitlab  laihz的账号里面
Welcome to GitLab, @laihz!
```



## Ubuntu24安装

```
sudo apt update

sudo curl -L "https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh" | sudo bash

sudo apt install gitlab-runner

sudo gitlab-runner -version
 
 # 启动服务
sudo systemctl start gitlab-runner

# 设置开机自启
sudo systemctl enable gitlab-runner

# 查看状态
sudo systemctl status gitlab-runner
```

### 注册

参考上面

### 配置文件地址

/etc/gitlab-runner/config.toml



示例

```yaml
variables:
  RUNNER_TAG: i7         #选择部署在i7或hasee服务器
  JOB_TRIGGER: "on_success"     # 全局控制作业触发方式，可改为 "on_success" 自动执行

stages:
  - build
  - deploy

build:
  stage: build
  variables:
    GIT_STRATEGY: none
  tags:
    - $RUNNER_TAG
  script:
    # 1. 删除旧代码
    - rm -rf /home/gitlab-runner/goproject/jinjiang-data-cleaning

    # 2. 克隆当前提交的分支
    - git clone -b "$CI_COMMIT_REF_NAME" ssh://git@125.124.128.235:50022/project/jinjiang-data-cleaning.git /home/gitlab-runner/goproject/jinjiang-data-cleaning

    # 3. 进入代码目录
    - cd /home/gitlab-runner/goproject/jinjiang-data-cleaning

    # 4. 删除旧镜像（如果存在）
    - sudo docker rmi -f jinjiang-data-cleaning:"$CI_COMMIT_REF_NAME" || true
    # 5. 构建 Docker 镜像
    - sudo docker build -t jinjiang-data-cleaning:"$CI_COMMIT_REF_NAME" .
  rules:
    # 分支为 feature-readtable 且 JOB_TRIGGER=manual 时手动触发
    - if: '$CI_COMMIT_REF_NAME == "feature-readtable" && $JOB_TRIGGER == "manual"'
      when: manual
    # 分支为 feature-readtable 且 JOB_TRIGGER=on_success 时自动执行
    - if: '$CI_COMMIT_REF_NAME == "feature-readtable" && $JOB_TRIGGER == "on_success"'
      when: on_success
    # 其他分支不运行
    - when: never

deploy:
  stage: deploy
  variables:
    GIT_STRATEGY: none
  tags:
    - $RUNNER_TAG
  script:
    - sudo docker rm -f jinjiang-data-cleaning || true
    - sudo docker run -itd --privileged --name jinjiang-data-cleaning --network host -v /home/laihz/app:/app/output jinjiang-data-cleaning:"$CI_COMMIT_REF_NAME"
  rules:
    - if: '$CI_COMMIT_REF_NAME == "feature-readtable" && $JOB_TRIGGER == "manual"'
      when: manual
    - if: '$CI_COMMIT_REF_NAME == "feature-readtable" && $JOB_TRIGGER == "on_success"'
      when: on_success
    - when: never

```





Dockerfile

```dockerfile
# 使用官方Go镜像作为构建阶段
FROM m.daocloud.io/docker.io/golang:1.22.2-alpine AS builder

# 设置 Go 中国大陆代理 & 关闭 GOSUMDB
ENV GOPROXY=https://goproxy.cn,direct
ENV GOSUMDB=off

# 设置工作目录
WORKDIR /app

# 安装必要的工具
RUN apk add --no-cache git make

# 复制 go mod 文件
COPY go.mod go.sum ./

# 下载依赖
RUN go mod download

# 复制源代码
COPY . .

# 构建应用
RUN make build

# ---------- 运行阶段保持不变 ----------
FROM m.daocloud.io/docker.io/alpine:latest

RUN apk --no-cache add tzdata

RUN cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && \
    echo "Asia/Shanghai" > /etc/timezone

RUN addgroup -g 1001 -S appgroup && \
    adduser -u 1001 -S appuser -G appgroup

WORKDIR /app

COPY --from=builder /app/data-clean .
COPY --from=builder /app/config ./config
COPY --from=builder /app/start.sh .

RUN chown -R appuser:appgroup /app

USER appuser

ENTRYPOINT ["sh", "-c"]
CMD ["./start.sh > /dev/null 2>&1; echo \"启动脚本执行完毕，状态码: $?\"; echo \"容器继续运行...\"; tail -f /dev/null"]

```

