---
layout: post
title: "malloc代码分析"
category: Csapp (cmu 15-213)

---

CSAPP malloc lab

# csapp 课本模拟malloc代码分析

思路：

1. 把内存看作一个数组，数组的index就是内存地址,例如地址从（0x7ffff69a4010-0x7ffff7da4010），每个地址可以保存1BYTE(8位)的数据，学过java的可以理解为 byte[] arry=new byte[size]。

2. 以word为最小单位（4BYTE），一个BLOCK节点包含head（4BYTE），body（按分配），foot（4BYTE）。
3. head和foot保存BLCOK的size和alloc，来实现先前向后遍历整个数组。
4. 初始一个word无用块，2个word头块，1个word 尾块
5. 下面例子中相同颜色（浅蓝色深蓝色区分是foot还是head）的就是一个BLOCK

![image-20240427143332371]({{ "/assets/malloc/image-20240427143332371.png" | absolute_url }})

```c
#include "mm.h"
#include "memlib.h"
#include <stdio.h>

int main()
{
    mem_init();//开辟20MB空间  0x7ffff69a4010-0x7ffff7da4010
    int mmres = mm_init();
    if (mmres==0)
    {
        int *p = (int *)mm_malloc(sizeof(int));
        *p=100;

        printf("hello world p= %d\n",*p);
                            
        mm_free(p);
    }
    
}

void mem_init(void)
{
    mem_heap = (char *)Malloc(MAX_HEAP);//(20*(1<<20))  /* 20 MB */
    mem_brk = (char *)mem_heap;               
    mem_max_addr = (char *)(mem_heap + MAX_HEAP); 
}

```

# 宏

```c
//构造一个4个字节的头的内容，size代表blcok大小，alloc代表是否被分配（0未分配，1空闲）
PACK(size, alloc)  ((size) | (alloc)) 

//代表一个word为4字节
WSIZE=4

//代表双字（Double word）8BYTE
DSIZE=8

```





## mm_init()函数

```c
int mm_init(void) 
{
    /* Create the initial empty heap */
    if ((heap_listp = mem_sbrk(4*WSIZE)) == (void *)-1) //line:vm:mm:begininit
        return -1;
    PUT(heap_listp, 0);                          /* Alignment padding */
    PUT(heap_listp + (1*WSIZE), PACK(DSIZE, 1)); /* Prologue header */ 
    PUT(heap_listp + (2*WSIZE), PACK(DSIZE, 1)); /* Prologue footer */ 
    PUT(heap_listp + (3*WSIZE), PACK(0, 1));     /* Epilogue header */
    heap_listp += (2*WSIZE);                     //line:vm:mm:endinit  
    /* $end mminit */

    
    /* $begin mminit */
    /* Extend the empty heap with a free block of CHUNKSIZE bytes */
    if (extend_heap(CHUNKSIZE/WSIZE) == NULL) 
        return -1;
    return 0;
}


static void *extend_heap(size_t words) 
{
    char *bp;
    size_t size;

    /* Allocate an even number of words to maintain alignment */
    size = (words % 2) ? (words+1) * WSIZE : words * WSIZE; //line:vm:mm:beginextend
    if ((long)(bp = mem_sbrk(size)) == -1)  
        return NULL;                                        //line:vm:mm:endextend

    /* Initialize free block header/footer and the epilogue header */
    PUT(HDRP(bp), PACK(size, 0));         /* Free block header */   //line:vm:mm:freeblockhdr
    PUT(FTRP(bp), PACK(size, 0));         /* Free block footer */   //line:vm:mm:freeblockftr
    PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1)); /* New epilogue header */ //line:vm:mm:newepihdr

    /* Coalesce if the previous block was free */
    return coalesce(bp);                                          //line:vm:mm:returnblock
}
```



### 初始heap_listp = mem_sbrk(4*WSIZE)

注意图中`4010代表0x7ffff69a4010，省略掉前面0x7ffff69a`

![image-20240427143035383](/assets/malloc/image-20240427143035383.png)

### 头节点和尾节点的指针

![image-20240427143332371]({{ "/assets/malloc/image-20240427143332371.png" | absolute_url }})

### extend_heap(4096) 扩容产生一些free block(4096/4=1024块)

![image-20240427143345614]({{ "/assets/malloc/image-20240427143345614.png" | absolute_url }})

##  int *p = (int *)mm_malloc(sizeof(int));

### find_fit(size)

### 找到空闲block，采用首次适应算法

``` c
for (bp = heap_listp; GET_SIZE(HDRP(bp)) > 0; bp = NEXT_BLKP(bp)) {
        char *hp = HDRP(bp);//获取当前body的头，原理是往4字节，bp-4；
        int cur_size = GET_SIZE(hp); //根据头获取body大小
        int is_alloc = GET_ALLOC(hp);//根据头获取是否空闲
        if ((!is_alloc) && (asize <= cur_size)) {
            return bp;
        }
    }
```

bp代表当前指针（指向4018），从prologue的body出发，先查看head里面的size和是is_alloc,如图蓝色block，现在size=8，is_alloc=1，均不满足，bp再指向下一个块body（因为知道当前的szie，指针只需要往后走size长度即可）

bp代表当前指针（指向4020），满足条件返回bp=4020

### place(void *bp, size_t asize)

把空闲块一分为2，构造新的已分配block和空闲block.

```c
static void place(void *bp, size_t asize)
/* $end mmplace-proto */
{
    char *hp = HDRP(bp);
    size_t csize = GET_SIZE(hp);   

    if ((csize - asize) >= (2*DSIZE)) { 
        int pack1 = PACK(asize, 1);
        PUT(HDRP(bp), pack1);
        int pack2 = PACK(asize, 1);
        char * fp = FTRP(bp);
        PUT(fp, pack2);
        bp = NEXT_BLKP(bp);

        int pk3 = PACK(csize-asize, 0);
        PUT(HDRP(bp), pk3);
        int pk4 = PACK(csize-asize, 0);
        PUT(FTRP(bp), PACK(csize-asize, 0));
    }
    else { 
        PUT(HDRP(bp), PACK(csize, 1));
        PUT(FTRP(bp), PACK(csize, 1));
    }
}
```



